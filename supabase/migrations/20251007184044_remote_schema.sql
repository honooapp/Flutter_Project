create type "public"."hinoo_type" as enum ('personal', 'moon', 'answer');

create table "public"."hinoo" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "pages" jsonb not null,
    "reply_to" uuid,
    "recipient_tag" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "fingerprint" text,
    "type" hinoo_type not null default 'personal'::hinoo_type
);


alter table "public"."hinoo" enable row level security;

create table "public"."hinoo_drafts" (
    "user_id" uuid not null,
    "payload" jsonb not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."hinoo_drafts" enable row level security;

create table "public"."honoo" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "text" text not null,
    "image_url" text not null default ''::text,
    "created_at" timestamp with time zone not null default now(),
    "destination" text not null default ''::text,
    "reply_to" uuid,
    "user_id" uuid not null,
    "recipient_tag" text,
    "updated_at" timestamp with time zone
);


alter table "public"."honoo" enable row level security;

create table "public"."house_access" (
    "id" bigint generated by default as identity not null,
    "target_house_tag" text,
    "visitor_id" uuid default gen_random_uuid(),
    "granted_at" timestamp without time zone
);


alter table "public"."house_access" enable row level security;

create table "public"."users" (
    "id" bigint generated by default as identity not null,
    "address" text,
    "house_open" boolean not null,
    "auth_id" uuid
);


alter table "public"."users" enable row level security;

CREATE INDEX hinoo_created_idx ON public.hinoo USING btree (created_at DESC);

CREATE UNIQUE INDEX hinoo_drafts_pkey ON public.hinoo_drafts USING btree (user_id);

CREATE UNIQUE INDEX hinoo_pkey ON public.hinoo USING btree (id);

CREATE INDEX hinoo_user_idx ON public.hinoo USING btree (user_id);

CREATE UNIQUE INDEX honoo_pkey ON public.honoo USING btree (id);

CREATE UNIQUE INDEX house_access_pkey ON public.house_access USING btree (id);

CREATE UNIQUE INDEX users_address_key ON public.users USING btree (address);

CREATE UNIQUE INDEX users_auth_id_key ON public.users USING btree (auth_id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

alter table "public"."hinoo" add constraint "hinoo_pkey" PRIMARY KEY using index "hinoo_pkey";

alter table "public"."hinoo_drafts" add constraint "hinoo_drafts_pkey" PRIMARY KEY using index "hinoo_drafts_pkey";

alter table "public"."honoo" add constraint "honoo_pkey" PRIMARY KEY using index "honoo_pkey";

alter table "public"."house_access" add constraint "house_access_pkey" PRIMARY KEY using index "house_access_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."hinoo" add constraint "hinoo_pages_len" CHECK (((jsonb_typeof(pages) = 'array'::text) AND ((jsonb_array_length(pages) >= 1) AND (jsonb_array_length(pages) <= 9)))) not valid;

alter table "public"."hinoo" validate constraint "hinoo_pages_len";

alter table "public"."hinoo" add constraint "hinoo_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."hinoo" validate constraint "hinoo_user_id_fkey";

alter table "public"."hinoo_drafts" add constraint "hinoo_drafts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."hinoo_drafts" validate constraint "hinoo_drafts_user_id_fkey";

alter table "public"."users" add constraint "users_address_key" UNIQUE using index "users_address_key";

alter table "public"."users" add constraint "users_auth_id_key" UNIQUE using index "users_auth_id_key";

set check_function_bodies = off;

create or replace view "public"."hinoo_moon_public" as  SELECT id,
    user_id,
    pages,
    reply_to,
    recipient_tag,
    created_at,
    updated_at,
    fingerprint,
    type
   FROM hinoo
  WHERE (type = 'moon'::hinoo_type);


create or replace view "public"."hinoo_public" as  SELECT id,
    user_id,
    pages,
    reply_to,
    recipient_tag,
    created_at,
    updated_at,
    fingerprint,
    type
   FROM hinoo
  WHERE (type = 'moon'::hinoo_type);


CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end $function$
;

CREATE OR REPLACE FUNCTION public.set_user_id()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  new.user_id := auth.uid();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.storage_path_from_url(u text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  select
    case
      when u is null or length(u) = 0 then null
      when u like 'http%' and u ~ '/storage/v1/object/public/hinoo/' then
        regexp_replace(u, '^https?://[^/]+/storage/v1/object/public/hinoo/', '')
      else
        -- se già è un path (es. '<userId>/backgrounds/..')
        u
    end
$function$
;

create or replace view "public"."hinoo_storage_refs" as  WITH h_path AS (
         SELECT DISTINCT storage_path_from_url((slide.value ->> 'backgroundImage'::text)) AS path
           FROM (hinoo h
             CROSS JOIN LATERAL jsonb_array_elements(h.pages) slide(value))
          WHERE (slide.value ? 'backgroundImage'::text)
        ), d_path AS (
         SELECT DISTINCT storage_path_from_url((slide.value ->> 'backgroundImage'::text)) AS path
           FROM (hinoo_drafts d
             CROSS JOIN LATERAL jsonb_array_elements((d.payload -> 'pages'::text)) slide(value))
          WHERE (slide.value ? 'backgroundImage'::text)
        )
 SELECT h_path.path
   FROM h_path
  WHERE (COALESCE(h_path.path, ''::text) <> ''::text)
UNION
 SELECT d_path.path
   FROM d_path
  WHERE (COALESCE(d_path.path, ''::text) <> ''::text);


create policy "hinoo delete own"
on "public"."hinoo"
as permissive
for delete
to authenticated
using ((auth.uid() = user_id));


create policy "hinoo insert own"
on "public"."hinoo"
as permissive
for insert
to authenticated
with check ((auth.uid() = user_id));


create policy "hinoo public read moon"
on "public"."hinoo"
as permissive
for select
to authenticated
using ((type = 'moon'::hinoo_type));


create policy "hinoo select own"
on "public"."hinoo"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "hinoo update own"
on "public"."hinoo"
as permissive
for update
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "hinoo_drafts delete own"
on "public"."hinoo_drafts"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "hinoo_drafts select own"
on "public"."hinoo_drafts"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "hinoo_drafts update own"
on "public"."hinoo_drafts"
as permissive
for update
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "hinoo_drafts upsert own"
on "public"."hinoo_drafts"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Enable delete for users based on user_id"
on "public"."honoo"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Public moon honoo"
on "public"."honoo"
as permissive
for select
to public
using ((destination = 'moon'::text));


create policy "insert own honoo"
on "public"."honoo"
as permissive
for insert
to authenticated
with check (true);


create policy "select moon honoo"
on "public"."honoo"
as permissive
for select
to public
using ((destination = 'moon'::text));


create policy "select own honoo"
on "public"."honoo"
as permissive
for select
to authenticated
using ((auth.uid() = user_id));


create policy "select replies to me"
on "public"."honoo"
as permissive
for select
to authenticated
using (((destination = 'reply'::text) AND (recipient_tag IS NOT NULL) AND (recipient_tag IN ( SELECT users.address
   FROM users
  WHERE (users.auth_id = auth.uid())))));


create policy "update own honoo"
on "public"."honoo"
as permissive
for update
to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "insert own user"
on "public"."users"
as permissive
for insert
to authenticated
with check ((auth.uid() = auth_id));


create policy "select own user"
on "public"."users"
as permissive
for select
to authenticated
using ((auth.uid() = auth_id));


create policy "update own user"
on "public"."users"
as permissive
for update
to authenticated
using ((auth.uid() = auth_id));


CREATE TRIGGER trg_hinoo_updated BEFORE UPDATE ON public.hinoo FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_hinoo_drafts_updated BEFORE UPDATE ON public.hinoo_drafts FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_updated_at_on_honoo BEFORE UPDATE ON public.honoo FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_user_id_before_insert BEFORE INSERT ON public.honoo FOR EACH ROW EXECUTE FUNCTION set_user_id();



  create policy "Owners can delete their objects"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'honoo-images'::text) AND (owner = auth.uid())));



  create policy "Owners can update their objects"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'honoo-images'::text) AND (owner = auth.uid())))
with check (((bucket_id = 'honoo-images'::text) AND (owner = auth.uid())));



  create policy "Users upload in their own folder"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'honoo-images'::text) AND ((string_to_array(name, '/'::text))[1] = (auth.uid())::text)));



  create policy "hinoo objects owner delete"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'hinoo'::text) AND (split_part(name, '/'::text, 1) = (auth.uid())::text)));



  create policy "hinoo objects owner insert"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'hinoo'::text) AND (split_part(name, '/'::text, 1) = (auth.uid())::text)));



  create policy "hinoo objects owner update"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'hinoo'::text) AND (split_part(name, '/'::text, 1) = (auth.uid())::text)))
with check (((bucket_id = 'hinoo'::text) AND (split_part(name, '/'::text, 1) = (auth.uid())::text)));



  create policy "hinoo objects public read"
  on "storage"."objects"
  as permissive
  for select
  to anon, authenticated
using ((bucket_id = 'hinoo'::text));



